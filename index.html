<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Soccer Dribbler</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    canvas {
      display: block;
      border: 3px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      box-shadow: 0 0 50px rgba(0,0,0,0.7);
      max-width: 100vw;
      max-height: 100vh;
    }
  </style>
</head>
<body>
<canvas id="game" width="600" height="800"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// ─── Constants ───────────────────────────────────────────────────────────────
const W = 600, H = 800;
const GOAL_Y = 90;          // ball.y - ball.radius < GOAL_Y → win
const FIELD_PAD = 25;       // field boundary inset

// ─── State ────────────────────────────────────────────────────────────────────
let gameState = 'start';    // 'start' | 'playing' | 'win' | 'lose'
const keys = {};
let dangerFlash = 0;
let winParticles = [];
let defenderStartDelay = 0;

// ─── Touch / Joystick ─────────────────────────────────────────────────────────
const isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
const joystick = {
  active: false,
  touchId: null,
  baseX: 0, baseY: 0,
  knobX: 0, knobY: 0,
  dx: 0, dy: 0,
  radius: 60,
};

// ─── Defender reaction delay ──────────────────────────────────────────────────
// 18 frames (~0.3 s at 60 fps) — reduced from 25 so feinting is harder.
const DEFENDER_DELAY = 18;
const ballHistory = [];

// ─── Entities ─────────────────────────────────────────────────────────────────

// Player's striker — input moves this character; ball dribbles at their feet.
const striker = {
  x: W / 2, y: 720,
  vx: 0, vy: 0,
  radius: 16,
  speed: 0.44,
  friction: 0.82,
  maxSpeed: 6.5,
  heading: -Math.PI / 2,   // initially facing up toward goal
  dribbleRange: 28,         // extra px beyond contact where spring engages
};

// The ball — pushed around by striker contact / dribbling spring.
const ball = {
  x: W / 2, y: 686,        // starts just ahead of striker (striker.y - 34)
  vx: 0, vy: 0,
  radius: 13,
  friction: 0.88,
  maxSpeed: 9.0,
  rotation: 0,
};

// Opposing defender — harder than before.
const defender = {
  x: W / 2, y: 220,
  vx: 0, vy: 0,
  radius: 18,
  speed: 0.31,              // was 0.27
  friction: 0.80,
  maxSpeed: 5.2,            // was 4.6
  tackleRadius: 30,
  heading: Math.PI / 2,    // initially facing down toward ball
  maxTurnRate: 0.09,        // was 0.07 — pivots faster
};

// ─── Reset ────────────────────────────────────────────────────────────────────
function resetGame() {
  striker.x = W / 2; striker.y = 720;
  striker.vx = 0; striker.vy = 0;
  striker.heading = -Math.PI / 2;

  ball.x = W / 2;
  ball.y = striker.y - (striker.radius + ball.radius + 5);
  ball.vx = 0; ball.vy = 0; ball.rotation = 0;

  defender.x = W / 2; defender.y = 220;
  defender.vx = 0; defender.vy = 0;
  defender.heading = Math.PI / 2;

  dangerFlash = 0;
  winParticles = [];
  defenderStartDelay = 55; // ~0.9 s grace period (was 90 = ~1.5 s)

  ballHistory.length = 0;
  for (let i = 0; i < DEFENDER_DELAY; i++) {
    ballHistory.push({ x: ball.x, y: ball.y });
  }
}

// ─── Input ────────────────────────────────────────────────────────────────────
document.addEventListener('keydown', e => {
  keys[e.key] = true;
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) {
    e.preventDefault();
  }
  if (gameState !== 'playing') {
    resetGame();
    gameState = 'playing';
  }
});
document.addEventListener('keyup', e => { keys[e.key] = false; });
canvas.addEventListener('click', () => {
  if (gameState !== 'playing') { resetGame(); gameState = 'playing'; }
});

// ─── Touch helpers ────────────────────────────────────────────────────────────
function toCanvasCoords(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (clientX - rect.left) * (W / rect.width),
    y: (clientY - rect.top)  * (H / rect.height),
  };
}

function joystickActivate(touch) {
  const { x, y } = toCanvasCoords(touch.clientX, touch.clientY);
  joystick.active  = true;
  joystick.touchId = touch.identifier;
  joystick.baseX   = x;
  joystick.baseY   = y;
  joystick.knobX   = x;
  joystick.knobY   = y;
  joystick.dx      = 0;
  joystick.dy      = 0;
}

function joystickMove(touch) {
  const { x, y } = toCanvasCoords(touch.clientX, touch.clientY);
  let dx = x - joystick.baseX;
  let dy = y - joystick.baseY;
  const dist = Math.hypot(dx, dy);
  if (dist > joystick.radius) {
    dx = (dx / dist) * joystick.radius;
    dy = (dy / dist) * joystick.radius;
  }
  joystick.knobX = joystick.baseX + dx;
  joystick.knobY = joystick.baseY + dy;
  joystick.dx    = dx / joystick.radius;
  joystick.dy    = dy / joystick.radius;
}

function joystickRelease() {
  joystick.active  = false;
  joystick.touchId = null;
  joystick.dx      = 0;
  joystick.dy      = 0;
}

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  if (gameState !== 'playing') {
    resetGame();
    gameState = 'playing';
    return;
  }
  for (const touch of e.changedTouches) {
    if (!joystick.active) joystickActivate(touch);
  }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  for (const touch of e.changedTouches) {
    if (touch.identifier === joystick.touchId) joystickMove(touch);
  }
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  for (const touch of e.changedTouches) {
    if (touch.identifier === joystick.touchId) joystickRelease();
  }
}, { passive: false });

canvas.addEventListener('touchcancel', e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === joystick.touchId) joystickRelease();
  }
});

// ─── Update Striker ───────────────────────────────────────────────────────────
function updateStriker() {
  if (keys['ArrowLeft']  || keys['a'] || keys['A']) striker.vx -= striker.speed;
  if (keys['ArrowRight'] || keys['d'] || keys['D']) striker.vx += striker.speed;
  if (keys['ArrowUp']    || keys['w'] || keys['W']) striker.vy -= striker.speed;
  if (keys['ArrowDown']  || keys['s'] || keys['S']) striker.vy += striker.speed;

  if (joystick.active) {
    striker.vx += joystick.dx * striker.speed;
    striker.vy += joystick.dy * striker.speed;
  }

  striker.vx *= striker.friction;
  striker.vy *= striker.friction;

  const spd = Math.hypot(striker.vx, striker.vy);
  if (spd > striker.maxSpeed) {
    striker.vx = (striker.vx / spd) * striker.maxSpeed;
    striker.vy = (striker.vy / spd) * striker.maxSpeed;
  }

  // Update facing direction for visual purposes
  if (spd > 0.3) striker.heading = Math.atan2(striker.vy, striker.vx);

  striker.x += striker.vx;
  striker.y += striker.vy;

  striker.x = Math.max(FIELD_PAD + striker.radius, Math.min(W - FIELD_PAD - striker.radius, striker.x));
  striker.y = Math.max(striker.radius, Math.min(H - FIELD_PAD - striker.radius, striker.y));
}

// ─── Update Ball ──────────────────────────────────────────────────────────────
function updateBall() {
  const dx = ball.x - striker.x;
  const dy = ball.y - striker.y;
  const dist = Math.hypot(dx, dy);
  const contactDist = striker.radius + ball.radius;

  // Dribbling spring: when ball is near, pull it to the spot just ahead of the striker.
  // At sprint speed the ball trails ~5 px behind ideal — realistic dribbling lag.
  if (dist < contactDist + striker.dribbleRange) {
    const strikerSpeed = Math.hypot(striker.vx, striker.vy);
    if (strikerSpeed > 0.3) {
      const nx = striker.vx / strikerSpeed;
      const ny = striker.vy / strikerSpeed;
      const idealX = striker.x + nx * (contactDist + 6);
      const idealY = striker.y + ny * (contactDist + 6);
      ball.vx += (idealX - ball.x) * 0.15;
      ball.vy += (idealY - ball.y) * 0.15;
    }
  }

  // Hard collision: prevent ball from passing through striker body.
  if (dist < contactDist && dist > 0.001) {
    const nx = dx / dist;
    const ny = dy / dist;
    // Separate
    ball.x = striker.x + nx * contactDist;
    ball.y = striker.y + ny * contactDist;
    // Impulse along contact normal
    const relVx = ball.vx - striker.vx;
    const relVy = ball.vy - striker.vy;
    const dot = relVx * nx + relVy * ny;
    if (dot < 0) {
      ball.vx -= 1.5 * dot * nx;
      ball.vy -= 1.5 * dot * ny;
    }
  }

  ball.vx *= ball.friction;
  ball.vy *= ball.friction;

  const spd = Math.hypot(ball.vx, ball.vy);
  if (spd > ball.maxSpeed) {
    ball.vx = (ball.vx / spd) * ball.maxSpeed;
    ball.vy = (ball.vy / spd) * ball.maxSpeed;
  }

  ball.x += ball.vx;
  ball.y += ball.vy;

  // Rolling animation
  ball.rotation += ball.vx * 0.06;

  // Field boundary clamp
  ball.x = Math.max(FIELD_PAD + ball.radius, Math.min(W - FIELD_PAD - ball.radius, ball.x));
  ball.y = Math.max(ball.radius, Math.min(H - FIELD_PAD - ball.radius, ball.y));

  // Record position for defender's delayed perception
  ballHistory.push({ x: ball.x, y: ball.y });
  if (ballHistory.length > DEFENDER_DELAY) ballHistory.shift();
}

// ─── Update Defender ─────────────────────────────────────────────────────────
function updateDefender() {
  if (defenderStartDelay > 0) { defenderStartDelay--; return; }

  // Chase where the ball was DEFENDER_DELAY frames ago.
  const target = ballHistory[0] || ball;
  const dx = target.x - defender.x;
  const dy = target.y - defender.y;
  const dist = Math.hypot(dx, dy);

  if (dist > 1) {
    const desiredAngle = Math.atan2(dy, dx);

    let diff = desiredAngle - defender.heading;
    while (diff >  Math.PI) diff -= Math.PI * 2;
    while (diff < -Math.PI) diff += Math.PI * 2;

    diff = Math.max(-defender.maxTurnRate, Math.min(defender.maxTurnRate, diff));
    defender.heading += diff;

    const jitter = dist > 180 ? 0.10 : 0.03;
    defender.heading += (Math.random() - 0.5) * jitter;

    defender.vx += Math.cos(defender.heading) * defender.speed;
    defender.vy += Math.sin(defender.heading) * defender.speed;
  }

  defender.vx *= defender.friction;
  defender.vy *= defender.friction;

  const dspd = Math.hypot(defender.vx, defender.vy);
  if (dspd > defender.maxSpeed) {
    defender.vx = (defender.vx / dspd) * defender.maxSpeed;
    defender.vy = (defender.vy / dspd) * defender.maxSpeed;
  }

  defender.x += defender.vx;
  defender.y += defender.vy;

  defender.x = Math.max(FIELD_PAD + defender.radius, Math.min(W - FIELD_PAD - defender.radius, defender.x));
  defender.y = Math.max(GOAL_Y + defender.radius, Math.min(H - FIELD_PAD - defender.radius, defender.y));
}

// ─── Check Win / Lose ─────────────────────────────────────────────────────────
function checkConditions() {
  // Win: ball enters goal zone
  if (ball.y - ball.radius < GOAL_Y) {
    gameState = 'win';
    spawnWinParticles();
    return;
  }
  // Lose: defender tackles ball
  const dist = Math.hypot(ball.x - defender.x, ball.y - defender.y);
  if (dist < (ball.radius + defender.tackleRadius)) {
    gameState = 'lose';
    return;
  }
  // Danger flash when defender is close to ball
  if (dist < 100) dangerFlash = 6;
}

// ─── Win Particles ────────────────────────────────────────────────────────────
function spawnWinParticles() {
  for (let i = 0; i < 60; i++) {
    winParticles.push({
      x: ball.x, y: ball.y,
      vx: (Math.random() - 0.5) * 9,
      vy: (Math.random() - 0.5) * 9 - 3,
      life: 1.0,
      color: `hsl(${Math.random() * 360}, 90%, 60%)`,
      size: Math.random() * 6 + 3,
    });
  }
}

function updateParticles() {
  for (const p of winParticles) {
    p.x += p.vx; p.y += p.vy;
    p.vy += 0.25;
    p.life -= 0.018;
  }
  winParticles = winParticles.filter(p => p.life > 0);
}

// ─── Draw Field ───────────────────────────────────────────────────────────────
function drawField() {
  // Grass base
  ctx.fillStyle = '#3a7d2c';
  ctx.fillRect(0, 0, W, H);

  // Alternating grass stripes
  const stripeH = 80;
  for (let i = 0; i < Math.ceil(H / stripeH); i++) {
    if (i % 2 === 0) {
      ctx.fillStyle = 'rgba(0,0,0,0.06)';
      ctx.fillRect(0, i * stripeH, W, stripeH);
    }
  }

  // Field boundary
  ctx.strokeStyle = 'rgba(255,255,255,0.8)';
  ctx.lineWidth = 2;
  ctx.strokeRect(FIELD_PAD, FIELD_PAD, W - FIELD_PAD * 2, H - FIELD_PAD * 2);

  // Center line
  ctx.beginPath();
  ctx.moveTo(FIELD_PAD, H / 2);
  ctx.lineTo(W - FIELD_PAD, H / 2);
  ctx.stroke();

  // Center circle
  ctx.beginPath();
  ctx.arc(W / 2, H / 2, 60, 0, Math.PI * 2);
  ctx.stroke();

  // Center dot
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.beginPath();
  ctx.arc(W / 2, H / 2, 4, 0, Math.PI * 2);
  ctx.fill();

  // Top penalty box
  ctx.strokeRect(W / 2 - 100, FIELD_PAD, 200, 90);
  // Bottom penalty box
  ctx.strokeRect(W / 2 - 100, H - FIELD_PAD - 90, 200, 90);

  // Top small box (goal area)
  ctx.strokeRect(W / 2 - 55, FIELD_PAD, 110, 40);
  // Bottom small box
  ctx.strokeRect(W / 2 - 55, H - FIELD_PAD - 40, 110, 40);

  // ── Goal at top ──
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 4;
  ctx.strokeRect(W / 2 - 60, 5, 120, FIELD_PAD);

  // Goal net lines
  ctx.strokeStyle = 'rgba(255,255,255,0.4)';
  ctx.lineWidth = 1;
  for (let nx = W / 2 - 50; nx <= W / 2 + 50; nx += 20) {
    ctx.beginPath();
    ctx.moveTo(nx, 5);
    ctx.lineTo(nx, FIELD_PAD);
    ctx.stroke();
  }

  // Goal glow
  const gGoal = ctx.createLinearGradient(0, 0, 0, GOAL_Y + 20);
  gGoal.addColorStop(0, 'rgba(255,230,0,0.3)');
  gGoal.addColorStop(1, 'rgba(255,230,0,0)');
  ctx.fillStyle = gGoal;
  ctx.fillRect(W / 2 - 60, 5, 120, GOAL_Y + 15);

  // "GOAL" arrow indicator
  ctx.fillStyle = 'rgba(255,220,0,0.9)';
  ctx.font = 'bold 13px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('▲ GOAL ▲', W / 2, GOAL_Y + 20);
}

// ─── Draw Ball ────────────────────────────────────────────────────────────────
function drawBall() {
  ctx.save();
  ctx.translate(ball.x, ball.y);

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(3, ball.radius - 4, ball.radius, 5, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.rotate(ball.rotation);

  // White base
  ctx.fillStyle = 'white';
  ctx.beginPath();
  ctx.arc(0, 0, ball.radius, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = '#222';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Soccer ball patches
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.arc(0, 0, 4, 0, Math.PI * 2);
  ctx.fill();

  const pR = ball.radius * 0.62;
  for (let i = 0; i < 5; i++) {
    const a = (i / 5) * Math.PI * 2 - Math.PI / 2;
    ctx.beginPath();
    ctx.arc(Math.cos(a) * pR, Math.sin(a) * pR, 3.2, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.restore();
}

// ─── Draw Striker ─────────────────────────────────────────────────────────────
function drawStriker() {
  ctx.save();
  ctx.translate(striker.x, striker.y);

  // Ground shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath();
  ctx.ellipse(3, striker.radius + 2, striker.radius - 2, 6, 0, 0, Math.PI * 2);
  ctx.fill();

  // Body — blue jersey (player's team)
  ctx.fillStyle = '#1565C0';
  ctx.beginPath();
  ctx.arc(0, 0, striker.radius, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#0D47A1';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Jersey number 9
  ctx.fillStyle = 'white';
  ctx.font = 'bold 14px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('9', 0, 2);

  // Head
  ctx.fillStyle = '#f4a261';
  ctx.beginPath();
  ctx.arc(0, -striker.radius - 8, 10, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#c47841';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  ctx.restore();
}

// ─── Draw Defender ───────────────────────────────────────────────────────────
function drawDefender() {
  ctx.save();
  ctx.translate(defender.x, defender.y);

  // Ground shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath();
  ctx.ellipse(3, defender.radius + 2, defender.radius - 2, 6, 0, 0, Math.PI * 2);
  ctx.fill();

  // Body — red jersey
  ctx.fillStyle = '#e63946';
  ctx.beginPath();
  ctx.arc(0, 0, defender.radius, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#9b1c28';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Jersey number
  ctx.fillStyle = 'white';
  ctx.font = 'bold 14px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('5', 0, 2);

  // Head
  ctx.fillStyle = '#f4a261';
  ctx.beginPath();
  ctx.arc(0, -defender.radius - 8, 10, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#c47841';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  ctx.restore();
}

// ─── Draw Joystick ────────────────────────────────────────────────────────────
function drawJoystick() {
  if (!joystick.active) return;

  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(joystick.baseX, joystick.baseY, joystick.radius, 0, Math.PI * 2);
  ctx.stroke();

  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.fill();

  ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(joystick.baseX, joystick.baseY);
  ctx.lineTo(joystick.knobX, joystick.knobY);
  ctx.stroke();

  ctx.globalAlpha = 0.75;
  ctx.fillStyle = '#4fc3f7';
  ctx.beginPath();
  ctx.arc(joystick.knobX, joystick.knobY, 24, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.7)';
  ctx.lineWidth = 2;
  ctx.stroke();

  ctx.restore();
}

// ─── Draw HUD ─────────────────────────────────────────────────────────────────
function drawHUD() {
  // Danger flash
  if (dangerFlash > 0) {
    ctx.fillStyle = `rgba(220,30,30,${(dangerFlash / 6) * 0.22})`;
    ctx.fillRect(0, 0, W, H);
    dangerFlash--;
  }

  // "DEFENDER CLOSE!" warning — based on defender-to-ball distance
  const dist = Math.hypot(ball.x - defender.x, ball.y - defender.y);
  if (dist < 80 && defenderStartDelay === 0) {
    ctx.fillStyle = `rgba(255,60,60,${Math.min(1, (80 - dist) / 50)})`;
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('⚠ DEFENDER CLOSE!', W / 2, H / 2 + 30);
  }

  drawJoystick();
}

// ─── Draw Overlay Helper ──────────────────────────────────────────────────────
function drawOverlay(color, title, titleColor, subtitle, prompt) {
  ctx.fillStyle = color;
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  roundRect(ctx, W / 2 - 200, H / 2 - 130, 400, 270, 16);
  ctx.fill();

  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 2;
  roundRect(ctx, W / 2 - 200, H / 2 - 130, 400, 270, 16);
  ctx.stroke();

  ctx.fillStyle = titleColor;
  ctx.font = 'bold 48px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = 'black';
  ctx.shadowBlur = 8;
  ctx.fillText(title, W / 2, H / 2 - 70);
  ctx.shadowBlur = 0;

  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.font = '18px Arial';
  ctx.fillText(subtitle, W / 2, H / 2 - 10);

  ctx.fillStyle = 'rgba(180,220,180,0.85)';
  ctx.font = '14px Arial';
  const controlsText = isTouchDevice ? 'Touch & drag for joystick' : 'WASD or Arrow Keys to move';
  ctx.fillText(controlsText, W / 2, H / 2 + 30);

  if (Math.floor(Date.now() / 550) % 2 === 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.font = 'bold 15px Arial';
    ctx.fillText(prompt, W / 2, H / 2 + 90);
  }
}

// ─── Draw Start Screen ───────────────────────────────────────────────────────
function drawStartScreen() {
  drawField();

  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = 'rgba(10,30,10,0.88)';
  roundRect(ctx, W / 2 - 210, H / 2 - 175, 420, 360, 18);
  ctx.fill();

  ctx.strokeStyle = 'rgba(100,200,100,0.5)';
  ctx.lineWidth = 2;
  roundRect(ctx, W / 2 - 210, H / 2 - 175, 420, 360, 18);
  ctx.stroke();

  ctx.fillStyle = '#f4d03f';
  ctx.font = 'bold 46px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = 'black'; ctx.shadowBlur = 10;
  ctx.fillText('⚽ SOCCER DRIBBLER', W / 2, H / 2 - 115);
  ctx.shadowBlur = 0;

  const controlHint = isTouchDevice
    ? '  Touch & drag — virtual joystick'
    : '  WASD / Arrow Keys — move striker';
  const lines = [
    'Dribble past the defender to score!',
    'Control your striker — ball follows!',
    '',
    controlHint,
    '  Push the ball into the yellow goal',
    '  Don\'t let #5 tackle the ball!',
  ];

  ctx.font = '17px Arial';
  lines.forEach((line, i) => {
    ctx.fillStyle = i < 2 ? 'rgba(255,255,180,0.95)' : 'rgba(200,240,200,0.85)';
    ctx.fillText(line, W / 2, H / 2 - 45 + i * 30);
  });

  if (Math.floor(Date.now() / 600) % 2 === 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.font = 'bold 16px Arial';
    const startPrompt = isTouchDevice
      ? '▶  Tap to play  ◀'
      : '▶  Press any key or click to play  ◀';
    ctx.fillText(startPrompt, W / 2, H / 2 + 145);
  }
}

// ─── Draw Win Screen ──────────────────────────────────────────────────────────
function drawWinScreen() {
  for (const p of winParticles) {
    ctx.save();
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
  updateParticles();

  drawOverlay(
    'rgba(0,120,0,0.45)',
    'GOAL! ⚽',
    '#f4d03f',
    'You dribbled past the defender!',
    isTouchDevice ? '▶  Tap to play again  ◀' : '▶  Press any key to play again  ◀'
  );
}

// ─── Draw Lose Screen ─────────────────────────────────────────────────────────
function drawLoseScreen() {
  drawOverlay(
    'rgba(180,0,0,0.40)',
    'TACKLED!',
    '#ff6b6b',
    'The defender got the ball!',
    isTouchDevice ? '▶  Tap to try again  ◀' : '▶  Press any key to try again  ◀'
  );
}

// ─── Rounded Rect Helper ──────────────────────────────────────────────────────
function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// ─── Main Game Loop ───────────────────────────────────────────────────────────
function gameLoop() {
  ctx.clearRect(0, 0, W, H);

  if (gameState === 'start') {
    drawStartScreen();
  } else if (gameState === 'playing') {
    updateStriker();
    updateBall();
    updateDefender();
    checkConditions();

    drawField();
    drawDefender();
    drawStriker();
    drawBall();
    drawHUD();
  } else if (gameState === 'win') {
    drawField();
    drawDefender();
    drawStriker();
    drawBall();
    drawWinScreen();
  } else if (gameState === 'lose') {
    drawField();
    drawDefender();
    drawStriker();
    drawBall();
    drawLoseScreen();
  }

  requestAnimationFrame(gameLoop);
}

// Initialise all state before first frame
resetGame();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
